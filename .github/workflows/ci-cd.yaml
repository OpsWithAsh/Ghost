name: CI-CD

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: ghost-app
  AWS_REGION: us-east-1
  ECR_REPO: ghost-app
  SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

# REQUIRED FOR AWS OIDC
permissions:
  id-token: write
  contents: read

############################
# 1ï¸âƒ£ PREPARE METADATA
############################
jobs:
  prepare:
    name: Prepare metadata
    runs-on: [self-hosted, devops-runner]
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
      - id: meta
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
          echo "image_tag=${SHORT_SHA}" >> $GITHUB_OUTPUT

############################
# 2ï¸âƒ£ SONARQUBE
############################
  sonarqube:
    name: SonarQube Analysis
    needs: prepare
    runs-on: [self-hosted, devops-runner]
    steps:
      - uses: actions/checkout@v4
      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v2
        with:
          args: >
            -Dsonar.projectKey=ghost-app
            -Dsonar.sources=ghost,apps
            -Dsonar.exclusions=**/node_modules/**
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }}
            -Dsonar.login=${{ secrets.SONAR_TOKEN }}

############################
# 3ï¸âƒ£ BUILD & PUSH IMAGE
############################
  build_push:
    name: Build & Push Image
    needs: sonarqube
    runs-on: [self-hosted, devops-runner]
    env:
      IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Image
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          IMAGE=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}

          docker buildx build \
            -t ${IMAGE}:${IMAGE_TAG} \
            -t ${IMAGE}:latest \
            --push .

############################
# 4ï¸âƒ£ DEPLOY TO STAGING (DOCKER)
############################
  deploy_staging:
    name: Deploy to Staging
    needs: build_push
    runs-on: [self-hosted, devops-runner]
    steps:
      - uses: actions/checkout@v4
      - name: SSH & Deploy (Staging)
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_SSH_USER: ${{ secrets.STAGING_SSH_USER }}
          STAGING_SSH_KEY: ${{ secrets.STAGING_SSH_KEY }}
        run: |
          echo "${STAGING_SSH_KEY}" > key.pem
          chmod 600 key.pem
          scp -i key.pem deploy/docker-compose.staging.yml ${STAGING_SSH_USER}@${STAGING_HOST}:~/ghost/docker-compose.yml
          ssh -i key.pem ${STAGING_SSH_USER}@${STAGING_HOST} <<'EOF'
            cd ~/ghost
            docker compose pull
            docker compose up -d
          EOF

############################
# 5ï¸âƒ£ SMOKE TEST STAGING
############################
  smoke_test_staging:
    name: Smoke Test Staging
    needs: deploy_staging
    runs-on: ubuntu-latest
    steps:
      - run: |
          for i in {1..30}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.STAGING_HEALTH_URL }}" || true)
            echo "Attempt $i => HTTP $code"
            [ "$code" = "200" ] && exit 0
            sleep 2
          done
          exit 1

############################
# 6ï¸âƒ£ DEPLOY TO PRODUCTION (DOCKER)
############################
  deploy_production:
    name: Deploy to Production
    needs: smoke_test_staging
    runs-on: [self-hosted, devops-runner]
    environment: production
    steps:
      - uses: actions/checkout@v4
      - name: SSH & Deploy (Prod)
        env:
          PROD_HOST: ${{ secrets.PROD_HOST }}
          PROD_SSH_USER: ${{ secrets.PROD_SSH_USER }}
          PROD_SSH_KEY: ${{ secrets.PROD_SSH_KEY }}
        run: |
          echo "${PROD_SSH_KEY}" > key.pem
          chmod 600 key.pem
          scp -i key.pem deploy/docker-compose.production.yml ${PROD_SSH_USER}@${PROD_HOST}:~/ghost/docker-compose.yml
          ssh -i key.pem ${PROD_SSH_USER}@${PROD_HOST} <<'EOF'
            cd ~/ghost
            docker compose pull
            docker compose up -d
          EOF

############################
# 7ï¸âƒ£ DEPLOY TO EKS (BLUE)
############################
  deploy_eks_blue:
    name: Deploy to EKS (Blue)
    needs: build_push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      # ðŸ” DEBUG â€“ SHOW FILE STRUCTURE
      - name: DEBUG â€“ Workspace
        run: |
          pwd
          ls -la
          find . -maxdepth 5 -type f

      # ðŸ” DEBUG â€“ FAIL FAST IF FILES MISSING
      - name: DEBUG â€“ Validate k8s files
        run: |
          test -f k8s/mysql.yaml || (echo "âŒ k8s/mysql.yaml missing" && exit 1)
          test -f k8s/ghost-config.yaml || (echo "âŒ k8s/ghost-config.yaml missing" && exit 1)
          test -f k8s/ghost-blue.yaml || (echo "âŒ k8s/ghost-blue.yaml missing" && exit 1)
          test -f k8s/ghost-service.yaml || (echo "âŒ k8s/ghost-service.yaml missing" && exit 1)

      # ðŸ” AWS OIDC
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::481665112009:role/GitHubActions-EKS-Role
          aws-region: us-east-1

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ghost-cluster --region us-east-1

      - name: Verify cluster
        run: kubectl get nodes

      # ðŸš€ DEPLOYMENTS
      - name: Deploy MySQL
        run: kubectl apply -f k8s/mysql.yaml

      - name: Deploy Ghost Config
        run: kubectl apply -f k8s/ghost-config.yaml

      - name: Deploy Ghost Blue
        run: kubectl apply -f k8s/ghost-blue.yaml

      - name: Deploy Ghost Service
        run: kubectl apply -f k8s/ghost-service.yaml

      - name: Verify Pods & Service
        run: |
          kubectl get pods -n ghost
          kubectl get svc -n ghost
